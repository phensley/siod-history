#! /bin/sh
# This is a shell archive. Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file". To overwrite existing
# files, type "sh file -c". You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g.. If this archive is complete, you
# will see the following message at the end:

# "End of archive 2 (of 3)."
# Contents: siod.doc sliba.c sql_rdb.c


# Wrapped by vi...@gw.home.vix.com on Thu May 19 18:48:34 1994
PATH=/bin:/usr/bin:/usr/ucb ; export PATH

if test -f 'siod.doc' -a "${1}" != "-c" ; then
echo shar: Will not clobber existing file \"'siod.doc'\"
else
echo shar: Extracting \"'siod.doc'\" \(24460 characters\)
sed "s/^X//" >'siod.doc' <<'END_OF_FILE'


X * COPYRIGHT (c) 1988-1994 BY *
X * PARADIGM ASSOCIATES INCORPORATED, CAMBRIDGE, MASSACHUSETTS. *
X * See the source file SLIB.C for more information. *
X

XDocumentation for Release 3.0 1-MAY-1994, George Carrette
X
X[Release Notes:]
X
X1.4 This release is functionally the same as release 1.3 but has been
Xremodularized in response to people who have been encorporating SIOD
Xas an interpreted extension language in other systems.
X
X1.5 Added the -g flag to enable mark-and-sweep garbage collection.
X The default is stop-and-copy. (Note: changed default to mark-and-sweep)
X
X2.0 Set_Repl_Hooks, catch & throw.
X
X2.1 Additions to SIOD.SCM: Backquote, cond.
X
X2.2 User Type extension. Read-Macros. (From C-programmer level).
X
X2.3 save-forms. load with argument t, comment character, faster intern.
X -o flag gives obarray size. default 100.
X
X2.4 speed up arithmetic and the evaluator. fixes to siod.scm. no_interrupt
X around calls to C I/O. gen_readr.
X
X2.5 numeric arrays in siod.c
X
X2.6 remodularize .h files, procedure prototypes. gc, eval, print hooks
X now table-driven.
X
X2.7 hash tables, fasload.
X
X2.8 bug fixes.
X
X2.9 added trace.c, fseek, ftell, some fixes.
X
X3.0 Windows NT port. some cleanups. SQL support, more string stuff.
X Heap management flexibility, default to mark-and-sweep, suggestions
X by some code reviewers for comp.sources.unix.
X
Xg...@paradigm.com, g...@mitech.com
XGeorge Carrette
X


X
XParadigm Associates Inc Phone: 617-492-6079
X29 Putnam Ave, Suite 6
XCambridge, MA 02138
X

X[Files:]
X
X siod.h Declarations
X siodp.h private declarations.
X slib.c scheme library.
X sliba.c array library.
X siod.c a main program.
X trace.c an optional trace package.
X siod.scm Some scheme code
X pratt.scm A pratt-parser in scheme.
X sql_rdb.* DIGITAL RDB SQL SUPPORT
X sql_oracle.* Oracle Call Interface Support.
X
X
X[Motivation:]
X
XThe most obvious thing one should notice is that this lisp implementation
Xis extremely small. For example, the resulting binary executable file
Xon a VAX/VMS system with /notraceback/nodebug is 17 kilo-bytes.
X
XSmall enough to understand, the source file slib.c is 30 kilo-bytes.
X
XSmall enough to include in the smallest applications which require
Xcommand interpreters or extension languages.
X
XWe also want to be able to run code from the book "Structure and
XInterpretation of Computer Programs."
X
XTechniques used will be familiar to most lisp implementors. Having
Xobjects be all the same size, and having only two statically allocated
Xspaces simplifies and speeds up both consing and gc considerably. the
XMSUBR hack allows for a modular implementation of tail recursion,
Xan extension of the FSUBR that is, as far as I know, original.
XThe optional stop and copy garbage collector may be selected at runtime.
X
XError handling is rather crude. A topic taken with machine fault,
Xexception handling, tracing, debugging, and state recovery which we
Xcould cover in detail, but is clearly beyond the scope of this
Ximplementation. Suffice it to say that if you have a good symbolic
Xdebugger you can set a break point at "err" and observe in detail all
Xthe arguments and local variables of the procedures in question, since
Xthere is no casting of data types. For example, if X is an offending
Xor interesting object then examining X->type will give you the type,
Xand X->storage_as.cons will show the car and the cdr.
X
X[Invocation:]
X
Xsiod [-hXXXXX:[N]] [-iXXXXX] [-gX] [-oXXXXX] [-nXXXXX] [-sXXXXX] [-eXXXXX]
X -h where XXXXX is an integer, to specify the heap size, in obj cells,
X N is the optional number of heaps limit (default 2).
X -i where XXXXX is a filename to load before going into the repl loop.
X -g where X = 1 for stop-and-copy GC, X = 0 for mark-and-sweep.
X -o where XXXXX is the size of the symbol hash table to use, default 100.
X -n where XXXXX is the number of preconsed/interned non-negative numbers.
X -s where XXXXX is the number of bytes of machine recursion stack.
X -e where XXXXX is an expression to evaluate, then exit.
X
X Example:
X siod -isiod.scm -h100000:100
X
X[Garbage Collection:]
X
XThere are two storage management techniques which may be chosen at runtime
Xby specifying the -g argument flag.
X
X -g1 is stop-and-copy. This is the simplest and most
X portable implementation. GC is only done at toplevel.
X -g0 (the default) is mark-and-sweep. GC is done at any time,
X required or requested. However, the implementation is not as portable.
X
XIf you get strange errors on a machine architecture not listed
Xthen you may be forced to use -g1 until you investigate and contact
Xthe author for advise.
X
XDiscussion of stop-and-copy follows:
X
XAs one can see from the source, garbage collection is really quite an easy
Xthing. The procedure gc_relocate is about 25 lines of code, and
Xscan_newspace is about 15.
X
XThe real tricks in handling garbage collection are (in a copying gc):
X (1) keeping track of locations containing objects
X (2) parsing the heap (in the space scanning)
X
XThe procedure gc_protect is called once (e.g. at startup) on each
X"global" location which will contain a lisp object.
X
XThat leaves the stack. Now, if we had chosen not to use the argument
Xand return-value passing mechanism provided by the C-language
Ximplementation, (also known as the "machine stack" and "machine
Xprocedure calling mechanism) this lisp would be larger, slower, and
Xrather more difficult to read and understand. Furthermore it would be
Xconsiderably more painful to *add* functionality in the way of SUBR's
Xto the implementation.
X
XAside from writing a very machine and compiler specific assembling language
Xroutine for each C-language implementation, embodying assumptions about
Xthe placement choices for arguments and local values, etc, we
Xare left with the following limitation: "YOU CAN GC ONLY AT TOP-LEVEL"
X
XHowever, this fits in perfectly with the programming style imposed in
Xmany user interface implementations including the MIT X-Windows Toolkit.
XIn the X Toolkit, a callback or work procedure is not supposed to spend
Xmuch time implementing the action. Therefore it cannot have allocated
Xmuch storage, and the callback trampoline mechanism can post a work
Xprocedure to call the garbage collector when needed.
X
XOur simple object format makes parsing the heap rather trivial.
XIn more complex situations one ends up requiring object headers or markers
Xof some kind to keep track of the actual storage lengths of objects
Xand what components of objects are lisp pointers.
X
XBecause of the usefulness of strings, they were added by default into
XSIOD 2.6. The implementation requires a hook that calls the C library
Xmemory free procedure when an object is in oldspace and never
Xgot relocated to newspace. Obviously this slows down the mark-and-sweep
XGC, and removes one of the usual advantages it has over mark-and-sweep.
X
XDiscussion of mark-and-sweep follows:
X
XIn a mark-and-sweep GC the objects are not relocated. Instead
Xone only has to LOOK at objects which are referenced by the argument
Xframes and local variables of the underlying (in this case C-coded)
Ximplementation procedures. If a pointer "LOOKS" like it is a valid
Xlisp object (see the procedure mark_locations_array) then it may be marked,
Xand the objects it points to may be marked, as being in-use storage which
Xis not linked into the freelist in the gc_sweep phase.
X
XAnother advantage of the mark_and_sweep storage management technique is
Xthat only one heap is required.
X
XThis main disadvantages are:
X(1) start-up cost to initially link freelist.
X (can be avoided by more general but slower NEWCELL code).
X(2) does not COMPACT or LOCALIZE the use of storage. This is poor engineering
X practice in a virtual memory environment.
X(2) the entire heap must be looked at, not just the parts with useful storage.
X
XIn general, mark-and-sweep is slower in that it has to look at more
Xmemory locations for a given heap size, however the heap size can
Xbe smaller for a given problem being solved. More complex analysis
Xis required when READ-ONLY, STATIC, storage spaces are considered.
XAdditionally the most sophisticated stop-and-copy storage management
Xtechniques take into account considerations of object usage temporality.
X
XThe technique assumes that all machine registers the GC needs to
Xlook at will be saved by a setjmp call into the save_regs_gc_mark data.
X
X[Compilation:]
X
XThis code (version 2.7) has been compiled and run under the following:
X- SUN-IV, GCC (GNU C)
X- VAX/VMS, VAXC
X- MacIntosh, THINK C 5.0
X
XEarlier versions were compiled and run on the AMIGA, Encore, and 4.3BSD.
XThere are reports that the code will also compile and run under MS-DOS.
X
XOn all unix machines use (with floating-point flags as needed)
X
X %cc -O -c siod.c
X %cc -O -c slib.c
X %cc -O -c sliba.c
X %cc -o siod siod.o slib.o sliba.o
X
XIf cc doesn't work, try gcc (GNU C, Free Software Foundation, Cambridge MA).
X
Xon VAX/VMS:
X
X $ cc siod
X $ cc slib
X $ cc sliba
X $ link siod,slib,sliba,sys$input:/opt
X sys$library:vaxcrtl/share
X $ siod == "$" + F$ENV("DEFAULT") + "SIOD"
X
Xon AMIGA 500, ignore warning messages about return value mismatches,
X %lc siod.c
X %lc slib.c
X %lc sliba.c
X %blink lib:c.o,siod.o,slib.o,sliba.o to siod lib lib:lcm.lib,lib:lc.lib,lib:amiga.lib
X
Xin THINK C.
X The siod project must include siod.c,slib.c,slib.c,sliba.c,siodm.c, ANSI.
X The compilation option "require prototypes" should be used.
X
X[System:]
X
XThe interrupts called SIGINT and SIGFPE by the C runtime system are
Xhandled by invoking the lisp error procedure. SIGINT is usually caused
Xby the CONTROL-C character and SIGFPE by floating point overflow or underflow.
X
X[Syntax:]
X
XThe only special characters are the parenthesis and single quote.
XEverything else, besides whitespace of course, will make up a regular token.
XThese tokens are either symbols or numbers depending on what they look like.
XDotted-list notation is not supported on input, only on output.
X
X[Special forms:]
X
XThe CAR of a list is evaluated first, if the value is a SUBR of type 9 or 10
Xthen it is a special form.
X
X(define symbol value) is presently like (set! symbol value).
X
X(define (f . arglist) . body) ==> (define f (lambda arglist . body))
X
X(lambda arglist . body) Returns a closure.
X
X(if pred val1 val2) If pred evaluates to () then val2 is evaluated else val1.
X
X(begin . body) Each form in body is evaluated with the result of the last
Xreturned.
X
X(set! symbol value) Evaluates value and sets the local or global value of
Xthe symbol.
X
X(or x1 x2 x3 ...) Returns the first Xn such that Xn evaluated non-().
X
X(and x1 x2 x3 ...) Keeps evaluating Xj until one returns (), or Xn.
X
X(quote form). Input syntax 'form, returns form without evaluation.
X
X(let pairlist . body) Each element in pairlist is (variable value).
XEvaluates each value then sets of new bindings for each of the variables,
Xthen evaluates the body like the body of a progn. This is actually
Ximplemented as a macro turning into a let-internal form.
X
X(the-environment) Returns the current lexical environment.
X
X[Macro Special forms:]
X
XIf the CAR of a list evaluates to a symbol then the value of that symbol
Xis called on a single argument, the original form. The result of this
Xapplication is a new form which is recursively evaluated.
X
X[Built-In functions:]
X
XThese are all SUBR's of type 4,5,6,7, taking from 0 to 3 arguments
Xwith extra arguments ignored, (not even evaluated!) and arguments not
Xgiven defaulting to (). SUBR's of type 8 are lexprs, receiving a list
Xof arguments. Order of evaluation of arguments will depend on the
Ximplementation choice of your system C compiler.
X
Xconsp cons car cdr set-car! set-cdr!
X
Xnumber? + - * / < > eqv?
XThe arithmetic functions all take two arguments.
X
Xeq?, pointer objective identity. (Use eqv? for numbers.)
X
Xsymbolconc, takes symbols as arguments and appends them.
X
Xsymbol?
X
Xsymbol-bound? takes an optional environment structure.
Xsymbol-value also takes optional env.
Xset-symbol-value also takes optional env.
X
Xenv-lookup takes a symbol and an environment structure. If it returns
Xnon-nil the CAR will be the value of the symbol.
X
Xassq
X
Xread,print
X
Xeval, takes a second argument, an environment.
X
Xcopy-list. Copies the top level conses in a list.
X
X(apropos) returns a copy of the list of the symbols that have been interned.
X(apropos "m") returns a list of symbols containing "m"
X(apropos "m" "x" ...) returns a list containing "m" and "x" and ...
X
Xgc-status, prints out the status of garbage collection services, the
Xnumber of cells allocated and the number of cells free. If given
Xa () argument turns gc services off, if non-() turns gc services on.
XIn mark-and-sweep storage management mode the argument only turns on
Xand off verbosity of GC messages.
X
Xgc, does a mark-and-sweep garbage collection. If called with argument nil
Xdoes not print gc messages during the gc.
X
X(allocate-heap) will allocate an additional heap if available.
X
X(gc-info n) returns for n = 0 copying? 1 = n-current-heaps 2 = n-max-heaps
X3 = heap-size 4 = n-free-cells. e.g.


X
X(set! *after-gc* '(if (< (gc-info 4) 5000) (allocate-heap)))
X

Xload, given a filename (which must be a symbol, there are no strings)
Xwill read/eval all the forms in that file. An optional second argument,
Xif T causes returning of the forms in the file instead of evaluating them.
X
Xsave-forms, given a filename and a list of forms, prints the forms to the
Xfile. 3rd argument is optional, 'a to open the file in append mode.
X
Xquit, will exit back to the operating system.
X
Xerror, takes a symbol as its first argument, prints the pname of this
Xas an error message. The second argument (optional) is an offensive
Xobject. The global variable errobj gets set to this object for later
Xobservation. If a (*catch 'errobj ...) is in effect then errors throw
Xto this tag instead of jumping back to the toplevel read-eval-print loop.
X
Xnull?, not. are the same thing.
X
X*catch tag exp, Sets up a dynamic catch frame using tag. Then evaluates exp.
X
X*throw tag value, finds the nearest *catch with an EQ tag, and cause it to
Xreturn value.
X
X[Strings]
X
X(number->string x [base]) => "..."
X(string->number "..." [base]) => x
X(read-from-string "....")
X(string-append ...)
X(string-search "token" "string") => () or starting index.
X(substring "string" start end)
X(string-length "foo") => 3
X(string-trim " foo ") => "foo"
X(string-trim-left "foo ") => "foo "
X(string-trim-right " foo") => " foo"
X(string-upcase "foo") => "FOO")
X(string-downcase "FOO") => "foo"
X
X[Procedures in main program siod.c]
X
Xcfib is the same as standard-fib. You can time it and compare it with
Xstandard-fib to get an idea of the overhead of interpretation.
X
Xvms-debug invokes the VMS debugger. The one optional argument is
Xa string of vms-debugger commands. To show the current call
Xstack and then continue execution:
X
X (vms-debug "set module/all;show calls;go")
X
XOr, to single step and run at the same time:
X
X (vms-debug "for i=1 to 100 do (STEP);go")
X
XOr, to set up a breakpoint on errors:
X
X (vms-debug "set module slib;set break err;go")
X
X
X[Utility procedures in siod.scm:]
X
XShows how to define macros.
X
Xcadr,caddr,cdddr,replace,list.
X
X(defvar variable default-value)
X
XAnd for us old maclisp hackers, setq and defun, and progn, etc.
X
Xcall-with-current-continuation (Must load siod.scm)
XImplemented in terms of *catch and *throw. So upward continuations
Xare not allowed.
X
XA simple backquote (quasi-quote) implementation.
XMust load siod.scm
X
Xcond, a macro.
X
Xappend
X
Xnconc
X
X[TRACE]


X
X(trace procedure1 procedure2 ...)
X(untrace procedure1 procedure2 ...)
X

XNote: * trace is an fsubr, and can be used on internal procedures too.
X * only interpreted procedures (non-subrs) can be traced.
X
X(define (f x)
X (let ((g (lambda () ...)))
X (trace g)
X (g)))
X
X[Advanced I/O]
X
XEfficient binary I/O may be used to save non-cicular data structures.
XSee siod.scm for definitions of fasload and fasdump.
X
X(fopen filename mode) => file
X(fclose file)
X(getc file)
X(putc char file)
X
X(fread size file) => string ;; conses a new string.
X(fread string file) => length ;; stores into existing string.
X(fwrite string file)
X
X(fseek file offset direction)
X(ftell file) => offset
X
XNote: By combining the use of fast-print and fast-read with and without
X the use of tables, with clever use of ftell and fseek, it is possible
X to implement an efficient database of lisp expressions.
X
X(fast-read table) => expression
X(fast-print expression table)
X
XA table is a list containing 3 elements: (<file> <hash-table> <index>)
XWhen doing fast-print the index and hash-table are updated as data
Xis written to the file. If the index is () then symbol-printing is
Xnot optimized. fast-read uses just the <hash-table> as a way of
Xlooking up previously interned symbols that have been assigned
Xan index.
X
X[A streams implementation:]
X
XThe first thing we must do is decide how to represent a stream.
XThere is only one reasonable data structure available to us, the list.
XSo we might use (<stream-car> <cache-flag> <cdr-cache> <cdr-procedure>)
X
Xthe-empty-stream is just ().
X
Xempty-stream?
X
Xhead
X
Xtail
X
Xcons-stream is a special form. Wraps a lambda around the second argument.
X
X*cons-stream is the low-level constructor used by cons-stream.
X
Xfasload, fasldump. Take the obvious arguments, and are implemented
Xin terms of fast-read and fast-print.
X
Xcompile-file.
X
X[Arrays:]
X
X(cons-array size [type]) Where [type] is double, long, string, lisp or nil.
X(aref array index)
X(aset array index value)
X
Xfasload and fasdump are effective ways of storing and restoring numeric
Xarray data.
X
X[Benchmarks:]
X
XA standard-fib procedure is included in siod.scm so that everyone will
Xuse the same definition in any reports of speed. Make sure the return
Xresult is correct. use command line argument of
X %siod -h100000 -isiod.scm
X
X(standard-fib 10) => 55 ; 795 cons work.
X(standard-fib 15) => 610 ; 8877 cons work.
X(standard-fib 20) => 6765 ; 98508 cons work.
X
X[Porting:]
X
XSee the #ifdef definition of myruntime, which
Xshould be defined to return a double float, the number of cpu seconds
Xused by the process so far. It uses the the tms_utime slot, and assumes
Xa clock cycle of 1/60'th of a second.
X
XIf your system or C runtime needs to poll for the interrupt signal
Xmechanism to work, then define INTERRUPT_CHECK to be something
Xuseful.
X
XThe STACK_LIMIT and STACK_CHECK macros may need to be conditionized.
XThey currently assume stack growth downward in virtual address.
XThe subr (%%stack-limit setting non-verbose) may be used to change the
Xlimits at runtime.
X
XThe stack and register marking code used in the mark-and-sweep GC
Xis unlikely to work on machines that do not keep the procedure call
Xstack in main memory at all times. It is assumed that setjmp saves
Xall registers into the jmp_buff data structure.
X
XIf the stack is not always aligned (in LISP-PTR sense) then the
Xgc_mark_and_sweep procedure will not work properly.
X
XExample, assuming a byte addressed 32-bit pointer machine:
X
Xstack_start_ptr: [LISP-PTR(4)]
X [LISP-PTR(4)]
X [RANDOM(4)]
X [RANDOM(2)]
X [LISP-PTR(4)]
X [LISP-PTR(4)]
X [RANDOM(2)]
X [LISP-PTR(4)]
X [LISP-PTR(4)]
Xstack_end: [LISP-PTR(4)]
X
XAs mark_locations goes from start to end it will get off proper alignment
Xsomewhere in the middle, and therefore the stack marking operation will
Xnot properly identify some valid lisp pointers.
X
XFortunately there is an easy fix to this. A more aggressive use of
Xour mark_locations procedure will suffice.
X
XFor example, say that there might be 2-byte random objects inserted into
Xthe stack. Then use two calls to mark_locations:
X
X mark_locations(((char *)stack_start_ptr) + 0,((char *)&stack_end) + 0);
X mark_locations(((char *)stack_start_ptr) + 2,((char *)&stack_end) + 2);
X
XIf we think there might be 1-byte random objects, then 4 calls are required:
X
X mark_locations(((char *)stack_start_ptr) + 0,((char *)&stack_end) + 0);
X mark_locations(((char *)stack_start_ptr) + 1,((char *)&stack_end) + 1);
X mark_locations(((char *)stack_start_ptr) + 2,((char *)&stack_end) + 2);
X mark_locations(((char *)stack_start_ptr) + 3,((char *)&stack_end) + 3);
X
X
X[Interface to other programs:]
X
XIf your main program does not want to actually have a read/eval/print
Xloop, and instead wants to do something else entirely, then use
Xthe routine set_repl_hooks to set up for procedures for:
X
X * putting the prompt "> " and other info strings to standard output.
X
X * reading (getting) an expression
X
X * evaluating an expression
X
X * printing an expression.
X
XThe routine get_eof_val may be called inside your reading procedure
Xto return a value that will cause exit from the read/eval/print loop.
X
XIn order to call a single C function in the context of the repl loop,
Xyou can do the following:
X
Xint flag = 0;
X
Xvoid my_puts(st)
X char *st;
X{}
X
XLISP my_reader()
X{if (flag == 1)
X return(get_eof_val());
X flag == 1;
X return(NIL);}
X
XLISP my_eval(x)
X LISP x;
X{call_my_c_function();
X return(NIL);}
X
XLISP my_print(x)
X LISP x;
X{}
X
Xdo_my_c_function()
X{set_repl_hooks(my_puts,my_read,my_eval,my_print);
X repl_driver(1, /* or 0 if we do not want lisp's SIGINT handler */
X 0);}
X
X
XIf you need a completely different read-eval-print-loop, for example
Xone based in X-Window procedures such as XtAddInput, then you may want to
Xhave your own input-scanner and utilize a read-from-string kind of
Xfunction.
X
XFor example, this main program gets a string using fgets, and
Xevaluates the string without printing any information.


X
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X

X#include "siod.h"
X
Xvoid repl_c_string(char *);


X
Xint main(int argc,char **argv)

X{char *local_argv[3];
X char linebuff[256],*ptr;
X local_argv[0] = "siod";
X local_argv[1] = "-h50000";
X local_argv[2] = "-g0";
X print_welcome();
X process_cla(3,local_argv,1);


X print_hs_1();
X init_storage();
X init_subrs();
X init_trace();

X while(fgets(linebuff,sizeof(linebuff),stdin))
X {if (ptr == strchr(linebuff,'\n')) *ptr = 0;
X repl_c_string(linebuff);}


X printf("EXIT\n");}
X

Xvoid my_puts(char *st)
X{}
X
Xstatic char *repl_c_string_arg = NULL;
X
XLISP my_read(void)
X{LISP s;
X if (repl_c_string_arg == NULL)
X return(get_eof_val());
X s = strcons(strlen(repl_c_string_arg),repl_c_string_arg);
X repl_c_string_arg = NULL;
X return(read_from_string(s));}
X
XLISP my_print(LISP x)
X{}
X
Xvoid repl_c_string(char *str)
X{struct repl_hooks h;
X h.repl_puts = my_puts;
X h.repl_read = my_read;
X h.repl_eval = NULL;
X h.repl_print = my_print;
X repl_c_string_arg = str;
X repl_driver(1,1,&h);}
X
X
X[User Type Extension:]
X
XThere are 5 user types currently available. tc_user_1 through tc_user_5.
XIf you use them then you must at least tell the garbage collector about
Xthem. To do this you must have 4 functions,
X * a user_relocate, takes a object and returns a new copy.
X * a user_scan, takes an object and calls relocate on its subparts.
X * a user_mark, takes an object and calls gc_mark on its subparts or
X it may return one of these to avoid stack growth.
X * a user_free, takes an object to hack before it gets onto the freelist.
X
Xset_gc_hooks(type,
X user_relocate_fcn,
X user_scan_fcn,
X user_mark_fcn,
X user_free_fcn,
X &kind_of_gc);
X
Xkind_of_gc should be a long. It will receive 0 for mark-and-sweep, 1 for
Xstop-and-copy. Therefore set_gc_hooks should be called AFTER process_cla.
XYou must specify a relocate function with stop-and-copy. The scan
Xfunction may be NULL if your user types will not have lisp objects in them.
XUnder mark-and-sweep the mark function is required but the free function
Xmay be NULL.
X
XSee SIOD.C for a very simple string-append implementation example.
X
XYou might also want to extend the printer. This is optional.
X
Xset_print_hooks(type,fcn);
X
XThe fcn receives the object which should be printed to its second
Xargument, a FILE*.
X
XThe evaluator may also be extended, with the "application" of user defined
Xtypes following in the manner of an MSUBR.
X
XLastly there is a simple read macro facility.
X
Xvoid set_read_hooks(char *all_set,char *end_set,
X LISP (*fcn1)(),LISP (*fcn2)())
X
XAll_set is a string of all read macros. end_set are those
Xthat will end the current token.
X
XThe fcn1 will receive the character used to trigger
Xit and the struct gen_readio * being read from. It should return a lisp object.
X
Xthe fnc2 is optional, and is a user hook into the token => lisp object
Xconversion.
END_OF_FILE
if test 24460 -ne `wc -c <'siod.doc'`; then
echo shar: \"'siod.doc'\" unpacked with wrong size!
fi
# end of 'siod.doc'
fi
if test -f 'sliba.c' -a "${1}" != "-c" ; then
echo shar: Will not clobber existing file \"'sliba.c'\"
else
echo shar: Extracting \"'sliba.c'\" \(24669 characters\)
sed "s/^X//" >'sliba.c' <<'END_OF_FILE'
X/*

X * COPYRIGHT (c) 1988-1994 BY *
X * PARADIGM ASSOCIATES INCORPORATED, CAMBRIDGE, MASSACHUSETTS. *
X * See the source file SLIB.C for more information. *
X

XArray-hacking code moved to another source file.


X
X*/
X
X#include <stdio.h>

X#include <string.h>
X#include <setjmp.h>
X#include <stdlib.h>
X#include <ctype.h>
X


X#include "siod.h"
X#include "siodp.h"
X

XLISP bashnum = NIL;
X
Xvoid init_storage_a1(long type)
X{long j;
X struct user_type_hooks *p;
X set_gc_hooks(type,
X array_gc_relocate,
X array_gc_mark,
X array_gc_scan,
X array_gc_free,
X &j);
X set_print_hooks(type,array_prin1);
X p = get_user_type_hooks(type);
X p->fast_print = array_fast_print;
X p->fast_read = array_fast_read;
X p->equal = array_equal;
X p->c_sxhash = array_sxhash;}
X
Xvoid init_storage_a(void)
X{gc_protect(&bashnum);
X bashnum = newcell(tc_flonum);
X init_storage_a1(tc_string);
X init_storage_a1(tc_double_array);
X init_storage_a1(tc_long_array);
X init_storage_a1(tc_lisp_array);}
X
XLISP array_gc_relocate(LISP ptr)
X{LISP nw;
X if ((nw = heap) >= heap_end) gc_fatal_error();
X heap = nw+1;
X memcpy(nw,ptr,sizeof(struct obj));
X return(nw);}
X
Xvoid array_gc_scan(LISP ptr)
X{long j;
X if TYPEP(ptr,tc_lisp_array)
X for(j=0;j < ptr->storage_as.lisp_array.dim; ++j)
X ptr->storage_as.lisp_array.data[j] =
X gc_relocate(ptr->storage_as.lisp_array.data[j]);}
X
XLISP array_gc_mark(LISP ptr)
X{long j;
X if TYPEP(ptr,tc_lisp_array)
X for(j=0;j < ptr->storage_as.lisp_array.dim; ++j)
X gc_mark(ptr->storage_as.lisp_array.data[j]);
X return(NIL);}
X
Xvoid array_gc_free(LISP ptr)
X{switch (ptr->type)
X {case tc_string:
X free(ptr->storage_as.string.data);
X break;
X case tc_double_array:
X free(ptr->storage_as.double_array.data);
X break;
X case tc_long_array:
X free(ptr->storage_as.long_array.data);
X break;
X case tc_lisp_array:
X free(ptr->storage_as.lisp_array.data);
X break;}}
X
Xvoid array_prin1(LISP ptr,FILE *f)
X{int j;
X switch (ptr->type)
X {case tc_string:
X fput_st(f,"\"");
X fput_st(f,ptr->storage_as.string.data);
X fput_st(f,"\"");
X break;
X case tc_double_array:
X fput_st(f,"#(");
X for(j=0; j < ptr->storage_as.double_array.dim; ++j)
X {sprintf(tkbuffer,"%g",ptr->storage_as.double_array.data[j]);
X fput_st(f,tkbuffer);
X if ((j + 1) < ptr->storage_as.double_array.dim)
X fput_st(f," ");}
X fput_st(f,")");
X break;
X case tc_long_array:
X fput_st(f,"#(");
X for(j=0; j < ptr->storage_as.long_array.dim; ++j)
X {sprintf(tkbuffer,"%ld",ptr->storage_as.long_array.data[j]);
X fput_st(f,tkbuffer);
X if ((j + 1) < ptr->storage_as.long_array.dim)
X fput_st(f," ");}
X fput_st(f,")");
X break;
X case tc_lisp_array:
X fput_st(f,"#(");
X for(j=0; j < ptr->storage_as.lisp_array.dim; ++j)
X {lprin1f(ptr->storage_as.lisp_array.data[j],f);
X if ((j + 1) < ptr->storage_as.lisp_array.dim)
X fput_st(f," ");}
X fput_st(f,")");
X break;}}
X
XLISP strcons(long length,char *data)


X{long flag;
X LISP s;
X flag = no_interrupt(1);
X s = cons(NIL,NIL);

X s->type = tc_string;
X s->storage_as.string.data = must_malloc(length+1);
X s->storage_as.string.dim = length;
X if (data)
X {memcpy(s->storage_as.string.data,data,length);
X s->storage_as.string.data[length] = 0;}
X no_interrupt(flag);
X return(s);}


X
Xint rfs_getc(unsigned char **p)

X{int i;
X i = **p;
X if (!i) return(EOF);
X *p = *p + 1;
X return(i);}
X


Xvoid rfs_ungetc(unsigned char c,unsigned char **p)

X{*p = *p - 1;}
X
XLISP read_from_string(LISP x)
X{char *p;
X struct gen_readio s;
X p = get_c_string(x);
X s.getc_fcn = (int (*)(char *))rfs_getc;
X s.ungetc_fcn = (void (*)(int, char *))rfs_ungetc;
X s.cb_argument = (char *) &p;
X return(readtl(&s));}
X
XLISP aref1(LISP a,LISP i)
X{long k;
X if NFLONUMP(i) err("bad index to aref",i);
X k = (long) FLONM(i);
X if (k < 0) err("negative index to aref",i);
X switch (a->type)
X {case tc_string:
X if (k >= a->storage_as.string.dim) err("index too large",i);
X return(flocons((double) a->storage_as.string.data[k]));
X case tc_double_array:
X if (k >= a->storage_as.double_array.dim) err("index too large",i);
X return(flocons(a->storage_as.double_array.data[k]));
X case tc_long_array:
X if (k >= a->storage_as.long_array.dim) err("index too large",i);
X return(flocons(a->storage_as.long_array.data[k]));
X case tc_lisp_array:
X if (k >= a->storage_as.lisp_array.dim) err("index too large",i);
X return(a->storage_as.lisp_array.data[k]);
X default:
X return(err("invalid argument to aref",a));}}
X
Xvoid err1_aset1(LISP i)
X{err("index to aset too large",i);}
X
Xvoid err2_aset1(LISP v)
X{err("bad value to store in array",v);}
X


XLISP aset1(LISP a,LISP i,LISP v)

X{long k;
X if NFLONUMP(i) err("bad index to aset",i);
X k = (long) FLONM(i);
X if (k < 0) err("negative index to aset",i);
X switch (a->type)
X {case tc_string:
X if NFLONUMP(v) err2_aset1(v);
X if (k >= a->storage_as.string.dim) err1_aset1(i);
X a->storage_as.string.data[k] = (char) FLONM(v);
X return(v);
X case tc_double_array:
X if NFLONUMP(v) err2_aset1(v);
X if (k >= a->storage_as.double_array.dim) err1_aset1(i);
X a->storage_as.double_array.data[k] = FLONM(v);
X return(v);
X case tc_long_array:
X if NFLONUMP(v) err2_aset1(v);
X if (k >= a->storage_as.long_array.dim) err1_aset1(i);
X a->storage_as.long_array.data[k] = (long) FLONM(v);
X return(v);
X case tc_lisp_array:
X if (k >= a->storage_as.lisp_array.dim) err1_aset1(i);
X a->storage_as.lisp_array.data[k] = v;
X return(v);
X default:
X return(err("invalid argument to aset",a));}}
X
XLISP cons_array(LISP dim,LISP kind)
X{LISP a;
X long flag,n,j;
X if (NFLONUMP(dim) || (FLONM(dim) < 0))
X return(err("bad dimension to cons-array",dim));
X else
X n = (long) FLONM(dim);
X flag = no_interrupt(1);
X a = cons(NIL,NIL);
X if EQ(cintern("double"),kind)
X {a->type = tc_double_array;
X a->storage_as.double_array.dim = n;
X a->storage_as.double_array.data = (double *) must_malloc(n *
X sizeof(double));
X for(j=0;j<n;++j) a->storage_as.double_array.data[j] = 0.0;}
X else if EQ(cintern("long"),kind)
X {a->type = tc_long_array;
X a->storage_as.long_array.dim = n;
X a->storage_as.long_array.data = (long *) must_malloc(n * sizeof(long));
X for(j=0;j<n;++j) a->storage_as.long_array.data[j] = 0;}
X else if EQ(cintern("string"),kind)
X {a->type = tc_string;
X a->storage_as.double_array.dim = n+1;
X a->storage_as.string.data = (char *) must_malloc(n+1);
X a->storage_as.string.data[n] = 0;
X for(j=0;j<n;++j) a->storage_as.string.data[j] = ' ';}
X else if (EQ(cintern("lisp"),kind) || NULLP(kind))
X {a->type = tc_lisp_array;
X a->storage_as.lisp_array.dim = n;
X a->storage_as.lisp_array.data = (LISP *) must_malloc(n * sizeof(LISP));
X for(j=0;j<n;++j) a->storage_as.lisp_array.data[j] = NIL;}
X else
X err("bad type of array",kind);
X no_interrupt(flag);
X return(a);}
X
XLISP string_append(LISP args)
X{long size;
X LISP l,s;
X char *data;
X size = 0;
X for(l=args;NNULLP(l);l=cdr(l))
X size += strlen(get_c_string(car(l)));
X s = strcons(size,NULL);
X data = s->storage_as.string.data;
X data[0] = 0;
X for(l=args;NNULLP(l);l=cdr(l))
X strcat(data,get_c_string(car(l)));
X return(s);}
X
XLISP substring(LISP str,LISP start,LISP end)
X{long s,e,n;
X if NTYPEP(str,tc_string) err("not a string",str);
X n = str->storage_as.string.dim;
X s = get_c_long(start);
X if NULLP(end)
X e = n;
X else
X e = get_c_long(end);
X if ((s < 0) || (s > e)) err("bad start index",start);
X if ((e < 0) || (e > n)) err("bad end index",end);
X return(strcons(e-s,&str->storage_as.string.data[s]));}
X
XLISP string_search(LISP token,LISP str)
X{char *s1,*s2,*ptr;
X s1 = get_c_string(str);
X s2 = get_c_string(token);
X ptr = strstr(s1,s2);
X if (ptr)
X return(flocons(ptr - s1));
X else
X return(NIL);}
X
XLISP string_trim(LISP str)
X{char *start,*end;
X start = get_c_string(str);
X while(*start && (*start == ' ')) ++start;
X end = &start[strlen(start)];
X while((end > start) && (*(end-1) == ' ')) --end;
X return(strcons(end-start,start));}
X
XLISP string_trim_left(LISP str)
X{char *start,*end;
X start = get_c_string(str);
X while(*start && (*start == ' ')) ++start;
X end = &start[strlen(start)];
X return(strcons(end-start,start));}
X
XLISP string_trim_right(LISP str)
X{char *start,*end;
X start = get_c_string(str);
X end = &start[strlen(start)];
X while((end > start) && (*(end-1) == ' ')) --end;
X return(strcons(end-start,start));}
X
XLISP string_upcase(LISP str)
X{LISP result;
X char *s1,*s2;
X long j,n;
X s1 = get_c_string(str);
X n = strlen(s1);
X result = strcons(n,s1);
X s2 = get_c_string(result);
X for(j=0;j<n;++j) s2[j] = toupper(s2[j]);
X return(result);}
X
XLISP string_downcase(LISP str)
X{LISP result;
X char *s1,*s2;
X long j,n;
X s1 = get_c_string(str);
X n = strlen(s1);
X result = strcons(n,s1);
X s2 = get_c_string(result);
X for(j=0;j<n;++j) s2[j] = tolower(s2[j]);
X return(result);}
X
XLISP lreadstring(struct gen_readio *f)
X{int j,c,n;
X char *p;
X j = 0;
X p = tkbuffer;
X while(((c = GETC_FCN(f)) != '"') && (c != EOF))
X {if (c == '\\')
X {c = GETC_FCN(f);
X if (c == EOF) err("eof after \\",NIL);
X switch(c)
X {case 'n':
X c = '\n';
X break;
X case 't':
X c = '\t';
X break;
X case 'r':
X c = '\r';
X break;
X case 'd':
X c = 0x04;
X break;
X case 'N':
X c = 0;
X break;
X case 's':
X c = ' ';
X break;
X case '0':
X n = 0;
X while(1)
X {c = GETC_FCN(f);
X if (c == EOF) err("eof after \\0",NIL);
X if (isdigit(c))
X n = n * 8 + c - '0';
X else
X {UNGETC_FCN(c,f);
X break;}}
X c = n;}}
X if ((j + 1) >= TKBUFFERN) err("read string overflow",NIL);
X ++j;
X *p++ = c;}
X *p = 0;
X return(strcons(j,tkbuffer));}
X
X#define HASH_COMBINE(_h1,_h2,_mod) ((((_h1) * 17 + 1) ^ (_h2)) % (_mod))
X
Xlong c_sxhash(LISP obj,long n)
X{long hash;
X unsigned char *s;
X LISP tmp;
X struct user_type_hooks *p;
X STACK_CHECK(&obj);
X INTERRUPT_CHECK();
X switch TYPE(obj)
X {case tc_nil:
X return(0);
X case tc_cons:
X hash = c_sxhash(CAR(obj),n);
X for(tmp=CDR(obj);CONSP(tmp);tmp=CDR(tmp))
X hash = HASH_COMBINE(hash,c_sxhash(CAR(tmp),n),n);
X hash = HASH_COMBINE(hash,c_sxhash(tmp,n),n);
X return(hash);
X case tc_symbol:
X for(hash=0,s=(unsigned char *)PNAME(obj);*s;++s)
X hash = HASH_COMBINE(hash,*s,n);
X return(hash);
X case tc_subr_0:
X case tc_subr_1:
X case tc_subr_2:
X case tc_subr_3:
X case tc_lsubr:
X case tc_fsubr:
X case tc_msubr:
X for(hash=0,s=(unsigned char *) obj->storage_as.subr.name;*s;++s)
X hash = HASH_COMBINE(hash,*s,n);
X return(hash);
X case tc_flonum:
X return(((unsigned long)FLONM(obj)) % n);
X default:
X p = get_user_type_hooks(TYPE(obj));
X if (p->c_sxhash)
X return((*p->c_sxhash)(obj,n));
X else
X return(0);}}
X
XLISP sxhash(LISP obj,LISP n)
X{return(flocons(c_sxhash(obj,FLONUMP(n) ? (long) FLONM(n) : 10000)));}
X
XLISP equal(LISP a,LISP b)
X{struct user_type_hooks *p;
X long atype;
X STACK_CHECK(&a);
X loop:
X INTERRUPT_CHECK();
X if EQ(a,b) return(truth);
X atype = TYPE(a);
X if (atype != TYPE(b)) return(NIL);
X switch(atype)
X {case tc_cons:
X if NULLP(equal(car(a),car(b))) return(NIL);
X a = cdr(a);
X b = cdr(b);
X goto loop;
X case tc_flonum:
X return((FLONM(a) == FLONM(b)) ? truth : NIL);
X case tc_symbol:
X return(NIL);
X default:
X p = get_user_type_hooks(atype);
X if (p->equal)
X return((*p->equal)(a,b));
X else
X return(NIL);}}
X
XLISP array_equal(LISP a,LISP b)
X{long j,len;
X switch(TYPE(a))
X {case tc_string:
X len = a->storage_as.string.dim;
X if (len != b->storage_as.string.dim) return(NIL);
X if (memcmp(a->storage_as.string.data,b->storage_as.string.data,len) == 0)
X return(truth);
X else
X return(NIL);
X case tc_long_array:
X len = a->storage_as.long_array.dim;
X if (len != b->storage_as.long_array.dim) return(NIL);
X if (memcmp(a->storage_as.long_array.data,
X b->storage_as.long_array.data,
X len * sizeof(long)) == 0)
X return(truth);
X else
X return(NIL);
X case tc_double_array:
X len = a->storage_as.double_array.dim;
X if (len != b->storage_as.double_array.dim) return(NIL);
X for(j=0;j<len;++j)
X if (a->storage_as.double_array.data[j] !=
X b->storage_as.double_array.data[j])
X return(NIL);
X return(truth);
X case tc_lisp_array:
X len = a->storage_as.lisp_array.dim;
X if (len != b->storage_as.lisp_array.dim) return(NIL);
X for(j=0;j<len;++j)
X if NULLP(equal(a->storage_as.lisp_array.data[j],
X b->storage_as.lisp_array.data[j]))
X return(NIL);
X return(truth);


X default:
X return(errswitch());}}
X

Xlong array_sxhash(LISP a,long n)
X{long j,len,hash;
X unsigned char *char_data;
X unsigned long *long_data;
X double *double_data;
X switch(TYPE(a))
X {case tc_string:
X len = a->storage_as.string.dim;
X for(j=0,hash=0,char_data=(unsigned char *)a->storage_as.string.data;
X j < len;
X ++j,++char_data)
X hash = HASH_COMBINE(hash,*char_data,n);
X return(hash);
X case tc_long_array:
X len = a->storage_as.long_array.dim;
X for(j=0,hash=0,long_data=(unsigned long *)a->storage_as.long_array.data;
X j < len;
X ++j,++long_data)
X hash = HASH_COMBINE(hash,*long_data % n,n);
X return(hash);
X case tc_double_array:
X len = a->storage_as.double_array.dim;
X for(j=0,hash=0,double_data=a->storage_as.double_array.data;
X j < len;
X ++j,++double_data)
X hash = HASH_COMBINE(hash,(unsigned long)*double_data % n,n);
X return(hash);
X case tc_lisp_array:
X len = a->storage_as.lisp_array.dim;
X for(j=0,hash=0; j < len; ++j)
X hash = HASH_COMBINE(hash,
X c_sxhash(a->storage_as.lisp_array.data[j],n),
X n);
X return(hash);
X default:
X errswitch();
X return(0);}}


X
Xlong href_index(LISP table,LISP key)

X{long index;
X if NTYPEP(table,tc_lisp_array) err("not a hash table",table);
X index = c_sxhash(key,table->storage_as.lisp_array.dim);
X if ((index < 0) || (index >= table->storage_as.lisp_array.dim))
X {err("sxhash inconsistency",table);
X return(0);}
X else
X return(index);}
X
XLISP href(LISP table,LISP key)
X{return(cdr(assoc(key,
X table->storage_as.lisp_array.data[href_index(table,key)])));}
X
XLISP hset(LISP table,LISP key,LISP value)
X{long index;
X LISP cell,l;
X index = href_index(table,key);
X l = table->storage_as.lisp_array.data[index];
X if NNULLP(cell = assoc(key,l))
X return(setcdr(cell,value));
X cell = cons(key,value);
X table->storage_as.lisp_array.data[index] = cons(cell,l);
X return(value);}
X
XLISP assoc(LISP x,LISP alist)
X{LISP l,tmp;
X for(l=alist;CONSP(l);l=CDR(l))
X {tmp = CAR(l);
X if (CONSP(tmp) && equal(CAR(tmp),x)) return(tmp);
X INTERRUPT_CHECK();}
X if EQ(l,NIL) return(NIL);
X return(err("improper list to assoc",alist));}
X
Xvoid put_long(long i,FILE *f)
X{fwrite(&i,sizeof(long),1,f);}
X
Xlong get_long(FILE *f)
X{long i;
X fread(&i,sizeof(long),1,f);
X return(i);}


X
Xlong fast_print_table(LISP obj,LISP table)

X{FILE *f;
X LISP ht,index;
X f = get_c_file(car(table),(FILE *) NULL);
X if NULLP(ht = car(cdr(table)))
X return(1);
X index = href(ht,obj);
X if NNULLP(index)
X {putc(FO_fetch,f);
X put_long(get_c_long(index),f);
X return(0);}
X if NULLP(index = car(cdr(cdr(table))))
X return(1);
X hset(ht,obj,index);
X FLONM(bashnum) = 1.0;
X setcar(cdr(cdr(table)),plus(index,bashnum));
X putc(FO_store,f);
X put_long(get_c_long(index),f);
X return(1);}
X
XLISP fast_print(LISP obj,LISP table)
X{FILE *f;
X long len;
X LISP tmp;
X struct user_type_hooks *p;
X STACK_CHECK(&obj);
X f = get_c_file(car(table),(FILE *) NULL);
X switch(TYPE(obj))
X {case tc_nil:
X putc(tc_nil,f);
X return(NIL);
X case tc_cons:
X for(len=0,tmp=obj;CONSP(tmp);tmp=CDR(tmp)) {INTERRUPT_CHECK();++len;}
X if (len == 1)
X {putc(tc_cons,f);
X fast_print(car(obj),table);
X fast_print(cdr(obj),table);}
X else if NULLP(tmp)
X {putc(FO_list,f);
X put_long(len,f);
X for(tmp=obj;CONSP(tmp);tmp=CDR(tmp))
X fast_print(CAR(tmp),table);}
X else
X {putc(FO_listd,f);
X put_long(len,f);
X for(tmp=obj;CONSP(tmp);tmp=CDR(tmp))
X fast_print(CAR(tmp),table);
X fast_print(tmp,table);}
X return(NIL);
X case tc_flonum:
X putc(tc_flonum,f);
X fwrite(&obj->storage_as.flonum.data,
X sizeof(obj->storage_as.flonum.data),
X 1,
X f);
X return(NIL);
X case tc_symbol:
X if (fast_print_table(obj,table))
X {putc(tc_symbol,f);
X len = strlen(PNAME(obj));
X if (len >= TKBUFFERN)
X err("symbol name too long",obj);
X put_long(len,f);
X fwrite(PNAME(obj),len,1,f);
X return(truth);}
X else
X return(NIL);
X default:
X p = get_user_type_hooks(TYPE(obj));
X if (p->fast_print)
X return((*p->fast_print)(obj,table));
X else
X return(err("cannot fast-print",obj));}}
X
XLISP fast_read(LISP table)
X{FILE *f;
X LISP tmp,l;
X struct user_type_hooks *p;
X int c;
X long len;
X f = get_c_file(car(table),(FILE *) NULL);
X c = getc(f);
X if (c == EOF) return(table);
X switch(c)
X {case FO_fetch:
X len = get_long(f);
X FLONM(bashnum) = len;
X return(href(car(cdr(table)),bashnum));
X case FO_store:
X len = get_long(f);
X tmp = fast_read(table);
X hset(car(cdr(table)),flocons(len),tmp);
X return(tmp);
X case tc_nil:
X return(NIL);
X case tc_cons:
X tmp = fast_read(table);
X return(cons(tmp,fast_read(table)));
X case FO_list:
X case FO_listd:
X len = get_long(f);
X FLONM(bashnum) = len;
X l = make_list(bashnum,NIL);
X tmp = l;
X while(len > 1)
X {CAR(tmp) = fast_read(table);
X tmp = CDR(tmp);
X --len;}
X CAR(tmp) = fast_read(table);
X if (c == FO_listd)
X CDR(tmp) = fast_read(table);
X return(l);
X case tc_flonum:
X tmp = newcell(tc_flonum);
X fread(&tmp->storage_as.flonum.data,
X sizeof(tmp->storage_as.flonum.data),
X 1,
X f);
X return(tmp);
X case tc_symbol:
X len = get_long(f);
X if (len >= TKBUFFERN)
X err("symbol name too long",NIL);
X fread(tkbuffer,len,1,f);
X tkbuffer[len] = 0;
X return(rintern(tkbuffer));
X default:
X p = get_user_type_hooks(c);
X if (p->fast_read)
X return(*p->fast_read)(c,table);
X else
X return(err("unknown fast-read opcode",flocons(c)));}}
X
XLISP array_fast_print(LISP ptr,LISP table)
X{int j,len;
X FILE *f;
X f = get_c_file(car(table),(FILE *) NULL);
X switch (ptr->type)
X {case tc_string:
X putc(tc_string,f);
X len = ptr->storage_as.string.dim;
X put_long(len,f);
X fwrite(ptr->storage_as.string.data,len,1,f);
X return(NIL);
X case tc_double_array:
X putc(tc_double_array,f);
X len = ptr->storage_as.double_array.dim * sizeof(double);
X put_long(len,f);
X fwrite(ptr->storage_as.double_array.data,len,1,f);
X return(NIL);
X case tc_long_array:
X putc(tc_long_array,f);
X len = ptr->storage_as.long_array.dim * sizeof(long);
X put_long(len,f);
X fwrite(ptr->storage_as.long_array.data,len,1,f);
X return(NIL);
X case tc_lisp_array:
X putc(tc_lisp_array,f);
X len = ptr->storage_as.lisp_array.dim;
X put_long(len,f);
X for(j=0; j < len; ++j)
X fast_print(ptr->storage_as.lisp_array.data[j],table);
X return(NIL);


X default:
X return(errswitch());}}
X

XLISP array_fast_read(int code,LISP table)
X{long j,len,iflag;
X FILE *f;
X LISP ptr;
X f = get_c_file(car(table),(FILE *) NULL);
X switch (code)
X {case tc_string:
X len = get_long(f);
X ptr = strcons(len,NULL);
X fread(ptr->storage_as.string.data,len,1,f);
X ptr->storage_as.string.data[len] = 0;
X return(ptr);
X case tc_double_array:
X len = get_long(f);
X iflag = no_interrupt(1);
X ptr = newcell(tc_double_array);
X ptr->storage_as.double_array.dim = len;
X ptr->storage_as.double_array.data =
X (double *) must_malloc(len * sizeof(double));
X fread(ptr->storage_as.double_array.data,sizeof(double),len,f);
X no_interrupt(iflag);
X return(ptr);
X case tc_long_array:
X len = get_long(f);
X iflag = no_interrupt(1);
X ptr = newcell(tc_long_array);
X ptr->storage_as.long_array.dim = len;
X ptr->storage_as.long_array.data =
X (long *) must_malloc(len * sizeof(long));
X fread(ptr->storage_as.long_array.data,sizeof(long),len,f);
X no_interrupt(iflag);
X return(ptr);
X case tc_lisp_array:
X len = get_long(f);
X FLONM(bashnum) = len;
X ptr = cons_array(bashnum,NIL);
X for(j=0; j < len; ++j)
X ptr->storage_as.lisp_array.data[j] = fast_read(table);
X return(ptr);


X default:
X return(errswitch());}}
X

Xlong get_c_long(LISP x)
X{if NFLONUMP(x) err("not a number",x);
X return((long)FLONM(x));}
X
XLISP make_list(LISP x,LISP v)
X{long n;
X LISP l;
X n = get_c_long(x);
X l = NIL;
X while(n > 0)
X {l = cons(v,l); --n;}
X return(l);}
X
XLISP lfread(LISP size,LISP file)
X{long flag,n,ret,m;
X char *buffer;
X LISP s;
X FILE *f;
X f = get_c_file(file,NULL);
X flag = no_interrupt(1);
X if TYPEP(size,tc_string)
X {s = size;
X buffer = s->storage_as.string.data;
X n = s->storage_as.string.dim;
X m = 0;}
X else
X {n = get_c_long(size);
X buffer = (char *) must_malloc(n+1);
X buffer[n] = 0;
X m = 1;}
X ret = fread(buffer,1,n,f);
X if (ret == 0)
X {if (m)
X free(buffer);
X no_interrupt(flag);
X return(NIL);}
X if (m)
X {if (ret == n)
X {s = cons(NIL,NIL);
X s->type = tc_string;
X s->storage_as.string.data = buffer;
X s->storage_as.string.dim = n;}
X else
X {s = strcons(ret,NULL);
X memcpy(s->storage_as.string.data,buffer,ret);
X free(buffer);}
X no_interrupt(flag);
X return(s);}
X no_interrupt(flag);
X return(flocons((double)ret));}
X
XLISP lfwrite(LISP string,LISP file)
X{FILE *f;
X long flag;
X char *data;
X long dim;
X f = get_c_file(file,NULL);
X if NTYPEP(string,tc_string) err("not a string",string);
X data = string->storage_as.string.data;
X dim = string->storage_as.string.dim;
X flag = no_interrupt(1);
X fwrite(data,dim,1,f);


X no_interrupt(flag);
X return(NIL);}
X
X

XLISP string_length(LISP string)
X{if NTYPEP(string,tc_string) err("not a string",string);
X return(flocons((double)string->storage_as.string.dim));}
X
XLISP llength(LISP obj)
X{LISP l;
X long n;
X switch TYPE(obj)
X {case tc_string:
X return(flocons(obj->storage_as.string.dim));
X case tc_double_array:
X return(flocons(obj->storage_as.double_array.dim));
X case tc_long_array:
X return(flocons(obj->storage_as.long_array.dim));
X case tc_lisp_array:
X return(flocons(obj->storage_as.lisp_array.dim));
X case tc_nil:
X return(flocons(0.0));
X case tc_cons:
X for(l=obj,n=0;CONSP(l);l=CDR(l),++n) INTERRUPT_CHECK();
X if NNULLP(l) err("improper list to length",obj);
X return(flocons(n));
X default:
X return(err("wta to length",obj));}}
X
XLISP number2string(LISP x,LISP b)
X{char buffer[100];
X double y;
X long base;
X if NFLONUMP(x) err("wta",x);
X y = FLONM(x);
X if NULLP(b)
X sprintf(buffer,"%g",y);
X else if ((base = get_c_long(b)) == 10)
X sprintf(buffer,"%ld",(long)y);
X else if (base == 8)
X sprintf(buffer,"%lo",(long)y);
X else if (base == 16)
X sprintf(buffer,"%lX",(long)y);
X else
X err("number base not handled",b);
X return(strcons(strlen(buffer),buffer));}
X
XLISP string2number(LISP x,LISP b)
X{char *str;
X long base,value = 0;
X double result;
X str = get_c_string(x);
X if NULLP(b)
X result = atof(str);
X else if ((base = get_c_long(b)) == 10)
X {sscanf(str,"%ld",&value);
X result = (double) value;}
X else if (base == 8)
X {sscanf(str,"%lo",&value);
X result = (double) value;}
X else if (base == 16)
X {sscanf(str,"%lx",&value);
X result = (double) value;}
X else
X err("number base not handled",b);
X return(flocons(result));}
X
Xvoid init_subrs_a(void)
X{init_subr_2("aref",aref1);
X init_subr_3("aset",aset1);
X init_lsubr("string-append",string_append);
X init_subr_1("string-length",string_length);
X init_subr_1("read-from-string",read_from_string);
X init_subr_2("cons-array",cons_array);
X init_subr_2("sxhash",sxhash);
X init_subr_2("equal?",equal);
X init_subr_2("href",href);
X init_subr_3("hset",hset);
X init_subr_2("assoc",assoc);
X init_subr_1("fast-read",fast_read);
X init_subr_2("fast-print",fast_print);
X init_subr_2("make-list",make_list);
X init_subr_2("fread",lfread);
X init_subr_2("fwrite",lfwrite);
X init_subr_1("length",llength);
X init_subr_2("number->string",number2string);
X init_subr_2("string->number",string2number);
X init_subr_3("substring",substring);
X init_subr_2("string-search",string_search);
X init_subr_1("string-trim",string_trim);
X init_subr_1("string-trim-left",string_trim_left);
X init_subr_1("string-trim-right",string_trim_right);
X init_subr_1("string-upcase",string_upcase);
X init_subr_1("string-downcase",string_downcase);}
END_OF_FILE
if test 24669 -ne `wc -c <'sliba.c'`; then
echo shar: \"'sliba.c'\" unpacked with wrong size!
fi
# end of 'sliba.c'
fi
if test -f 'sql_rdb.c' -a "${1}" != "-c" ; then
echo shar: Will not clobber existing file \"'sql_rdb.c'\"
else
echo shar: Extracting \"'sql_rdb.c'\" \(26635 characters\)
sed "s/^X//" >'sql_rdb.c' <<'END_OF_FILE'


X/*****************************************************************************/
X/** **/
X/** Copyright (C) 1992-1994 BY **/
X/** MITECH CORPORATION, ACTON, MASSACHUSETTS. **/
X/** ALL RIGHTS RESERVED. **/
X/** **/
X/** Permission to use, copy, modify, distribute and sell this software **/
X/** and its documentation for any purpose and without fee is hereby **/
X/** granted, provided that the above copyright notice appear in all copies **/
X/** and that both that copyright notice and this permission notice appear **/
X/** in supporting documentation, and that the name of Mitech Corporation **/
X/** not be used in advertising or publicity pertaining to distribution **/
X/** of the software without specific, written prior permission. **/
X/** **/
X/** MITECH DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING **/
X/** ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL**/
X/** MITECH BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR **/
X/** ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, **/
X/** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, **/
X/** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS **/
X/** SOFTWARE. **/
X/** **/
X/*****************************************************************************/
X

X/* Interface from SIOD to DIGITAL RDB SQL SERVICES.


X 20-JAN-94 George Carrette. G...@MITECH.COM

X This is a good demonstration of the fact that a direct
X argument-for-argument translation of a C-language API into a lisp
X language API is inferior to the more studied approach used here,
X where we can eliminate the need for redundant arguments by encapsulation
X of state.
X
XBuilding: With SIOD 3.0, under VMS use $MMS/MACRO=("EXTRA=sql_rdb")
X which compiles siod.c with #define INIT_EXTRA init_sql_rdb
X and add sql_rdb.obj to the link statement.
X Or use $@MAKEFILE EXTRA SQL_RDB


X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>

X#include <sqlsrv.h>
X#include <math.h>
X
X#include "siod.h"
X
XLISP sym_ascii_string = NIL;
XLISP sym_generalized_number = NIL;
XLISP sym_generalized_date = NIL;
XLISP sym_varchar = NIL;
XLISP sym_varbyte = NIL;
XLISP sym_list_varbyte = NIL;
XLISP sym_table = NIL;
XLISP sym_list = NIL;
XLISP sym_update = NIL;
XLISP sym_read_only = NIL;
XLISP sym_insert_only = NIL;
XLISP sym_begin = NIL;
XLISP sym_end = NIL;
XLISP sym_abort = NIL;
X
XLISP associations = NIL;
X
Xlong cursor_gensym_counter = 0;
X
X#define tc_extra tc_user_5


X#define extra_tc_association 1
X#define extra_tc_statement 2
X

Xstruct association
X{LISP args;
X LISP statements;
X ASSOCIATE_ID id;
X char *error_buffer;
X char *read_buffer;
X char *write_buffer;
X long error_buffer_size;
X long read_buffer_size;
X long write_buffer_size;};
X
Xstruct statement
X{LISP association;
X LISP param_alist;
X LISP select_alist;
X LISP cursor;
X long id;
X SQLDA_ID params;
X SQLDA_ID selects;};
X
XLISP cadr(LISP x)
X{return(car(cdr(x)));}
X
XLISP list3(LISP a,LISP b,LISP c)
X{return(cons(a,cons(b,cons(c,NIL))));}
X
Xvoid ps_i(char *fmt,long n)
X{char buff[512];
X sprintf(buff,fmt,n);
X put_st(buff);}


X
Xstatic LISP extcons(long length,long typec)
X{long flag;
X LISP s;
X flag = no_interrupt(1);
X s = cons(NIL,NIL);
X s->type = tc_extra;
X s->storage_as.string.data = must_malloc(length);
X s->storage_as.string.dim = typec;
X memset(s->storage_as.string.data,0,length);
X no_interrupt(flag);
X return(s);}
X

XLISP sqlrtl_associate(LISP l)
X{LISP obj,tmp;
X long iflag,local_flag,status;
X struct ASSOCIATE_STR associate_str;
X struct association *a;
X char *nodename,*username,*password;
X long majerr,suberr1,suberr2;
X char errmsg[512],*estatus;
X memset(&associate_str,0,sizeof(associate_str));
X if NNULLP(cadr(assq(cintern("log"),l)))
X {associate_str.CLIENT_LOG = SQLSRV_LOG_ASSOCIATION + SQLSRV_LOG_ROUTINE;
X associate_str.SERVER_LOG = SQLSRV_LOG_ASSOCIATION;}
X iflag = no_interrupt(1);
X tmp = cadr(assq(cintern("node"),l));
X if NULLP(tmp)
X {local_flag = 1;
X nodename = "0";}
X else
X {local_flag = 0;
X nodename = get_c_string(tmp);}
X username = NNULLP(tmp = cadr(assq(cintern("username"),l)))
X ? get_c_string(tmp) : NULL;
X password = NNULLP(tmp = cadr(assq(cintern("password"),l)))
X ? get_c_string(tmp) : 0;
X obj = extcons(sizeof(struct association),extra_tc_association);
X a = (struct association *) obj->storage_as.string.data;
X a->args = l;
X a->statements = NIL;
X a->id = 0;
X a->error_buffer_size = 512;
X a->read_buffer_size = 1024;
X a->write_buffer_size = 1024;
X a->error_buffer = (char *) malloc(a->error_buffer_size);
X a->read_buffer = (char *) malloc(a->read_buffer_size);
X a->write_buffer = (char *) malloc(a->write_buffer_size);
X associate_str.ERRBUFLEN = a->error_buffer_size;
X associate_str.ERRBUF = (unsigned char *)a->error_buffer;
X associate_str.LOCAL_FLAG = local_flag;
X associate_str.MEMORY_ROUTINE = NULL;
X associate_str.FREE_MEMORY_ROUTINE = NULL;
X status = sqlsrv_associate(nodename,
X username,
X password,
X (unsigned char *)a->read_buffer,
X (unsigned char *)a->write_buffer,
X a->read_buffer_size,
X a->write_buffer_size,
X 0,
X &associate_str,
X &a->id);
X if (status == SQL_SUCCESS)
X {associations = cons(obj,associations);
X no_interrupt(iflag);
X return(obj);}
X if (a->id)
X /* The id may be set even though the status is not success.
X This area of the API is not well documented. */
X {sqlsrv_sqlca_error(a->id,&majerr,&suberr1,&suberr2);
X sqlsrv_release(a->id,0);}
X else
X {suberr1 = 0;
X suberr2 = 0;
X free(a->error_buffer);
X free(a->read_buffer);
X free(a->write_buffer);}
X sprintf(errmsg,"sqlsrv_associate error %d, %d, %d",
X status,suberr1,suberr2);
X return(err(errmsg,NIL));}
X
Xstruct association *get_association(LISP assoc,long oflag)
X{struct association *a;
X if ((TYPE(assoc) != tc_extra) ||
X (assoc->storage_as.string.dim != extra_tc_association))
X return(err("not an association",assoc));
X a = (struct association *)assoc->storage_as.string.data;
X if (a->id || !oflag)
X return(a);
X else
X {err("sqlsrv association has been released",assoc);
X return(NULL);}}
X
XLISP sqlrtl_associations(void)
X{return(associations);}
X
XLISP sqlrtl_release(LISP assoc)
X{struct association *a;
X long iflag,status;
X char errmsg[512];
X a = get_association(assoc,1);
X iflag = no_interrupt(1);
X status = sqlsrv_release(a->id,0);
X free(a->error_buffer);
X free(a->read_buffer);
X free(a->write_buffer);
X memset(a,0,sizeof(struct association));
X associations = delq(assoc,associations);
X if (status != SQL_SUCCESS)
X {sprintf(errmsg,"sqlsrv_release error %d",status);
X err(errmsg,NIL);}
X no_interrupt(iflag);
X return(nullp(NIL));}
X
XLISP sqlrtl_error(ASSOCIATE_ID id)
X{long majerr,suberr1,suberr2;
X char *estatus,errmsg[512];
X sqlsrv_sqlca_error(id,&majerr,&suberr1,&suberr2);
X sprintf(errmsg,"SQL error %d %d %d",majerr,suberr1,suberr2);
X return(err(errmsg,NIL));}
X
XLISP sqlrtl_status_error(long status)
X{char errmsg[512];
X sprintf(errmsg,"SQL error %d",status);
X return(err(errmsg,NIL));}
X
XLISP sqlrtl_sqlca_num_batch_rows(LISP assoc)
X{long status,iflag;
X struct association *a;
X a = get_association(assoc,1);
X iflag = no_interrupt(1);
X status = sqlsrv_sqlca_num_batch_rows(a->id);
X if (status >= 0)
X {no_interrupt(iflag);
X return(flocons(status));}
X else
X return(sqlrtl_error(a->id));}
X
XLISP sqlrtl_sqlca_count(LISP assoc)
X{long status,iflag;
X struct association *a;
X a = get_association(assoc,1);
X iflag = no_interrupt(1);
X status = sqlsrv_sqlca_count(a->id);
X if (status >= 0)
X {no_interrupt(iflag);
X return(flocons(status));}
X else
X return(sqlrtl_error(a->id));}
X
X
XLISP sqlrtl_execute_immediate(LISP assoc,LISP stmt)
X{long status,iflag;
X char *st;
X struct association *a;
X a = get_association(assoc,1);
X st = get_c_string(stmt);
X iflag = no_interrupt(1);
X status = sqlsrv_execute_immediate(a->id,0,st);
X if (status == SQL_SUCCESS)
X {no_interrupt(iflag);
X return(nullp(NIL));}
X else
X return(sqlrtl_error(a->id));}
X
XLISP sqlrtl_describe_association(LISP assoc)
X{struct association *a;
X a = get_association(assoc,0);
X put_st("An SQLSRV association\n");
X put_st("Opened with: ");
X lprin1f(a->args,stdout);
X put_st("\n");
X ps_i("Statements: %d\n",get_c_long(llength(a->statements)));
X if (a->id)
X {ps_i("Associate id: %x\n",a->id);
X put_st("error buffer: ");
X put_st(a->error_buffer);
X put_st("\n");}
X else
X put_st("which has been released\n");
X return(NIL);}
X
XLISP sqlrtl_sqlda_alist(SQLDA_ID x)
X{long i,n;
X char name[1000];
X LISP vtype,l;
X short namelen,type,scale;
X unsigned short len;
X n = sqlsrv_sqlda_sqld(x);
X l = NIL;
X for(i = 0; i < n; ++i)
X {sqlsrv_sqlda_column_name(x,i,&name[0],&namelen);
X sqlsrv_sqlda_column_type(x,i,&type,&len,&scale,0);
X switch(type)
X {case SQLSRV_ASCII_STRING: vtype = sym_ascii_string; break;
X case SQLSRV_GENERALIZED_NUMBER: vtype = sym_generalized_number; break;
X case SQLSRV_GENERALIZED_DATE: vtype = sym_generalized_date; break;
X case SQLSRV_VARCHAR: vtype = sym_varchar; break;
X case SQLSRV_VARBYTE: vtype = sym_varbyte; break;
X case SQLSRV_LIST_VARBYTE: vtype = sym_list_varbyte; break;
X default: vtype = NIL; break;}
X name[namelen] = 0;
X l = cons(list3(rintern(name),flocons(i),vtype),l);}
X return(nreverse(l));}
X
X#define SQL_WSR_CHARSET "\t\n"
X
XLISP sqlrtl_prepare(LISP assoc,LISP sql)
X{long iflag,status,tmpn;
X char *s,cname[32],*tmps = NULL,*ptr;
X struct statement *c;
X struct association *a;
X LISP st;
X a = get_association(assoc,1);
X s = get_c_string(sql);
X iflag = no_interrupt(1);
X st = extcons(sizeof(struct statement),extra_tc_statement);
X c = (struct statement *) st->storage_as.string.data;
X c->association = assoc;
X tmpn = strlen(s);
X if (tmpn != strcspn(s,SQL_WSR_CHARSET))
X {tmps = (char *) malloc(tmpn+1);
X strcpy(tmps,s);
X for(ptr=tmps;*ptr;++ptr) if (strchr(SQL_WSR_CHARSET,*ptr)) *ptr = ' ';
X s = tmps;}
X status = sqlsrv_prepare(a->id,0,s,&c->id,&c->params,&c->selects);
X if (tmps) free(tmps);
X if (status != SQL_SUCCESS)
X sqlrtl_error(a->id);
X if (c->params)
X {status = sqlsrv_allocate_sqlda_data(a->id,c->params);
X if (status != SQL_SUCCESS)
X {sqlsrv_release_statement(a->id,1,&c->id);
X sqlrtl_error(a->id);}}
X if (c->selects)
X {status = sqlsrv_allocate_sqlda_data(a->id,c->selects);
X if (status != SQL_SUCCESS)
X {sqlsrv_release_statement(a->id,1,&c->id);
X sqlrtl_error(a->id);}}
X c->param_alist = NIL;
X c->select_alist = NIL;
X c->cursor = NIL;
X a->statements = cons(st,a->statements);
X c->param_alist = sqlrtl_sqlda_alist(c->params);
X c->select_alist = sqlrtl_sqlda_alist(c->selects);
X if (c->selects)
X {sprintf(cname,"CUR_%06D",++cursor_gensym_counter);
X c->cursor = strcons(strlen(cname),cname);}
X no_interrupt(iflag);
X return(st);}
X
Xstruct statement *get_statement(LISP st)


X{if ((TYPE(st) != tc_extra) ||
X (st->storage_as.string.dim != extra_tc_statement))
X {err("not a statement",st);

X return(NULL);}
X else
X return((struct statement *)st->storage_as.string.data);}
X
XLISP sqlrtl_statement_params(LISP x)
X{return((get_statement(x))->params);}
X
XLISP sqlrtl_statement_selects(LISP x)
X{return((get_statement(x))->select_alist);}
X
XLISP sqlrtl_statement_association(LISP x)
X{return((get_statement(x))->association);}
X
Xvoid describe_sqlda(SQLDA_ID x)
X{long i,n;
X char name[100],*vtype;
X short namelen,type,scale;
X unsigned short len;
X n = sqlsrv_sqlda_sqld(x);
X ps_i("sqlda: %d elements\n",n);
X for(i = 0; i < n; ++i)
X {sqlsrv_sqlda_column_name(x,i,&name[0],&namelen);
X sqlsrv_sqlda_column_type(x,i,&type,&len,&scale,0);
X switch(type)
X {case SQLSRV_ASCII_STRING: vtype = "ASCII_STRING"; break;
X case SQLSRV_GENERALIZED_NUMBER: vtype = "GENERALIZED_NUMBER"; break;
X case SQLSRV_GENERALIZED_DATE: vtype = "GENERALIZED_DATE"; break;
X case SQLSRV_VARCHAR: vtype = "VARCHAR"; break;
X case SQLSRV_VARBYTE: vtype = "VARBYTE"; break;
X case SQLSRV_LIST_VARBYTE: vtype = "LIST_VARBYTE"; break;
X default: vtype = "????"; break;}
X name[namelen] = 0;
X put_st(name);
X put_st(": ");
X put_st(vtype);
X ps_i(" %d \n",len);}}
X
XLISP sqlrtl_describe_statement(LISP x)
X{struct statement *c;
X c = get_statement(x);
X put_st("A prepared SQL statement\n");
X ps_i("ID: %d\n",c->id);
X if (c->params)
X {put_st("param ");
X describe_sqlda(c->params);}
X if (c->selects)
X {put_st("select ");
X describe_sqlda(c->selects);
X put_st("Cursor: ");
X lprin1f(c->cursor,stdout);
X put_st("\n");}
X return(NIL);}
X
XLISP sqlrtl_release_statement(LISP x)
X{struct statement *c;
X struct association *a;
X LISP assoc;
X long status,iflag;
X c = get_statement(x);
X assoc = c->association;
X a = get_association(assoc,1);
X iflag = no_interrupt(1);
X status = sqlsrv_release_statement(a->id,1,&c->id);
X a->statements = delq(x,a->statements);
X if (status != SQL_SUCCESS)
X sqlrtl_error(a->id);


X no_interrupt(iflag);
X return(NIL);}
X

XLISP sqlrtl_declare_cursor(LISP stmt,LISP type,LISP mode)
X{long status,iflag,itype,imode;
X struct statement *c;
X struct association *a;
X LISP cursor;
X c = (struct statement *)get_statement(stmt);
X a = get_association(c->association,1);
X cursor = c->cursor;
X if NULLP(cursor)
X return(err("statement has no cursor",stmt));
X if (NULLP(type) && NULLP(mode))
X return(NIL);
X else
X {if EQ(type,sym_table)
X itype = SQLSRV_TABLE_CURSOR;
X else if EQ(type,sym_list)
X itype = SQLSRV_LIST_CURSOR;
X else
X err("invalid cursor type",type);
X if EQ(mode,sym_update)
X imode = SQLSRV_MODE_UPDATE;
X else if EQ(mode,sym_read_only)
X imode = SQLSRV_MODE_READ_ONLY;
X else if EQ(mode,sym_insert_only)
X imode = SQLSRV_MODE_INSERT_ONLY;
X else
X err("invalid cursor mode",mode);}
X iflag = no_interrupt(1);
X status = sqlsrv_declare_cursor(a->id,get_c_string(cursor),c->id,itype,imode);
X if (status == SQL_SUCCESS)
X {no_interrupt(iflag);
X return(nullp(NIL));}
X return(sqlrtl_error(a->id));}
X
XLISP sqlrtl_execute(LISP stmt,LISP batchp)
X{struct statement *c;
X struct association *a;
X long status,iflag,eflag;
X c = get_statement(stmt);
X a = get_association(c->association,1);
X if NULLP(batchp)
X eflag = 0;
X else if EQ(batchp,sym_begin)
X eflag = 1;
X else if EQ(batchp,sym_end)
X eflag = 2;
X else if EQ(batchp,sym_abort)
X eflag = 3;
X else
X err("invalid batch execute mode",batchp);
X iflag = no_interrupt(1);
X status = sqlsrv_execute(a->id,0,c->id,eflag,c->params);
X if (status == SQL_SUCCESS)
X {no_interrupt(iflag);
X return(nullp(NIL));}
X sqlrtl_error(a->id);}
X
XLISP sqlrtl_open_cursor(LISP stmt)
X{struct statement *c;
X struct association *a;
X long status,iflag;
X LISP cursor;
X c = get_statement(stmt);
X a = get_association(c->association,1);
X cursor = c->cursor;
X if NULLP(cursor)
X err("statement has no cursor",stmt);
X iflag = no_interrupt(1);
X status = sqlsrv_open_cursor(a->id,get_c_string(cursor),c->id,c->params);
X if (status == SQL_SUCCESS)
X {no_interrupt(iflag);
X return(nullp(NIL));}
X sqlrtl_error(a->id);}
X
XLISP sqlrtl_fetch(LISP stmt)
X{struct statement *c;
X struct association *a;
X long status,iflag;
X LISP cursor;
X c = get_statement(stmt);
X a = get_association(c->association,1);
X cursor = c->cursor;
X if NULLP(cursor)
X err("statement has no cursor",stmt);
X iflag = no_interrupt(1);
X status = sqlsrv_fetch(a->id,get_c_string(cursor),0,0,c->selects);
X switch(status)
X {case SQL_SUCCESS:
X case 1:
X /* with fetch_many in use this sometimes returned 1 */
X no_interrupt(iflag);
X return(nullp(NIL));
X case SQL_EOS:
X no_interrupt(iflag);
X return(NIL);
X default:
X sqlrtl_error(a->id);}}
X
XLISP sqlrtl_fetch_many(LISP stmt,LISP count)
X{struct statement *c;
X struct association *a;
X long status,iflag,k;
X LISP cursor;
X c = get_statement(stmt);
X a = get_association(c->association,1);
X cursor = c->cursor;
X if NULLP(cursor)
X err("statement has no cursor",stmt);
X if NULLP(count)
X k = 0;
X else
X k = get_c_long(count);
X iflag = no_interrupt(1);
X status = sqlsrv_fetch_many(a->id,get_c_string(cursor),0,k);
X switch(status)
X {case SQL_SUCCESS:
X no_interrupt(iflag);
X return(nullp(NIL));
X case SQL_EOS:
X no_interrupt(iflag);
X return(NIL);
X default:
X sqlrtl_error(a->id);}}
X
XLISP sqlrtl_close_cursor(LISP stmt)
X{struct statement *c;
X struct association *a;
X long status,iflag;
X LISP cursor;
X c = get_statement(stmt);
X a = get_association(c->association,1);
X cursor = c->cursor;
X if NULLP(cursor)
X err("statement has no cursor",stmt);
X iflag = no_interrupt(1);
X status = sqlsrv_close_cursor(a->id,get_c_string(cursor));
X if (status == SQL_SUCCESS)
X {no_interrupt(iflag);
X return(nullp(NIL));}
X sqlrtl_error(a->id);}
X
Xlong decnumpick(char *str,long len,long start,long count)
X{long n,c,j;
X if (start >= len)
X return(0);
X n = 0;
X for(j=0;(j<count) && str[j+start]; ++j)
X n = n * 10 + str[j+start] - '0';
X return(n);}
X
XLISP sqlrtl_get_datum(SQLDA_ID x,long k)
X{short typ,scl,nullp,varlen;
X unsigned short len;
X char *data;
X long status,iflag;
X LISP result;
X double d;
X iflag = no_interrupt(1);
X if (k < sqlsrv_sqlda_sqld(x))
X /* need to check because sqlsrv's currently does not correctly */
X status = sqlsrv_sqlda_map_data(x,k,&typ,&len,&scl,
X (unsigned char **)&data,&nullp,0);
X else
X status = SQLSRV_INVCOLNUM;
X if (status == SQL_SUCCESS)
X {if (nullp)
X result = NIL;
X else
X switch(typ)
X {case SQLSRV_ASCII_STRING:
X result = strcons(len,data);
X break;
X case SQLSRV_GENERALIZED_DATE:
X result = cons(flocons((double) decnumpick(data,len,12,2) +
X ((double) decnumpick(data,len,14,2)) / 100),
X NIL);
X result = cons(flocons(decnumpick(data,len,10,2)),result);
X result = cons(flocons(decnumpick(data,len,8,2)),result);
X result = cons(flocons(decnumpick(data,len,6,2)),result);
X result = cons(flocons(decnumpick(data,len,4,2)),result);
X result = cons(flocons(decnumpick(data,len,0,4)),result);
X break;
X case SQLSRV_GENERALIZED_NUMBER:
X data[len] = 0;
X d = atof(data);
X if (scl != 0)
X d = d * pow(10.0,- (double) scl);
X result = flocons(d);
X break;
X case SQLSRV_VARCHAR:
X varlen = *((unsigned short *) data);
X /* this varlen check is just paranoia */
X if (varlen > len) varlen = len;
X result = strcons(varlen,&data[2]);
X break;
X case SQLSRV_VARBYTE:
X case SQLSRV_LIST_VARBYTE:
X default:
X sqlsrv_sqlda_unmap_data(x,k);
X err("SQLSRV data type not handled",NIL);}
X sqlsrv_sqlda_unmap_data(x,k);
X no_interrupt(iflag);
X return(result);}
X sqlrtl_status_error(status);}
X
XLISP sqlrtl_get_param(LISP x,LISP n)
X{struct statement *c;
X c = get_statement(x);
X return(sqlrtl_get_datum(c->params,
X get_c_long(NNULLP(numberp(n)) ? n :
X cadr(assq(n,c->param_alist)))));}
X
XLISP sqlrtl_get_column(LISP x,LISP n)
X{struct statement *c;
X c = get_statement(x);
X return(sqlrtl_get_datum(c->selects,
X get_c_long(NNULLP(numberp(n)) ? n :
X cadr(assq(n,c->select_alist)))));}
X
Xvoid sqlrtl_put_datum(SQLDA_ID x,long k,LISP value)
X{short typ,scl,nullp;
X char *data,*string,num[100];
X long status,iflag,slen;
X double d;
X unsigned short len;
X iflag = no_interrupt(1);
X if (k < sqlsrv_sqlda_sqld(x))
X /* need to check because sqlsrv's currently does not correctly */
X status = sqlsrv_sqlda_map_data(x,k,&typ,&len,&scl,
X (unsigned char **)&data,&nullp,0);
X else
X status = SQLSRV_INVCOLNUM;
X if (status != SQL_SUCCESS)
X sqlrtl_status_error(status);
X switch(TYPE(value))
X {case tc_flonum:
X d = FLONM(value);
X if (scl != 0)
X d = d * pow(10.0,(double) scl);
X string = num;
X sprintf(string,"%g",d);
X break;
X case tc_symbol:
X case tc_string:
X string = get_c_string(value);
X break;
X default:
X sqlsrv_sqlda_unmap_data(x,k);
X err("lisp data type not handled",value);}
X slen = strlen(string);
X switch(typ)
X {case SQLSRV_ASCII_STRING:
X case SQLSRV_GENERALIZED_NUMBER:
X /* note: date is being handled as a string here, instead
X of the list of numbers that I returned in sqlrtl_get_datum. */
X case SQLSRV_GENERALIZED_DATE:
X /* note: not signalling error on truncation */
X if (slen > len)
X memcpy(data,string,len);
X else
X {memcpy(data,string,slen);
X if (len > slen)
X memset(&data[slen],' ',len-slen);}
X break;
X case SQLSRV_VARCHAR:
X if (slen > len)
X /* note: not signalling error on truncation */
X {memcpy(&data[2],string,len);
X *((unsigned short *) data) = len;}
X else
X {memcpy(&data[2],string,slen);
X *((unsigned short *) data) = slen;}
X break;
X case SQLSRV_VARBYTE:
X case SQLSRV_LIST_VARBYTE:
X default:
X sqlsrv_sqlda_unmap_data(x,k);
X err("SQLSRV data type not handled",NIL);}
X sqlsrv_sqlda_unmap_data(x,k);
X no_interrupt(iflag);}
X
XLISP sqlrtl_set_param(LISP x,LISP n,LISP value)
X{struct statement *c;
X c = get_statement(x);
X sqlrtl_put_datum(c->params,
X get_c_long(NNULLP(numberp(n)) ? n :
X cadr(assq(n,c->param_alist))),
X value);
X return(NIL);}
X
XLISP sqlrtl_release_generic(LISP x)
X{if ((TYPE(x) != tc_extra) ||
X ((x->storage_as.string.dim != extra_tc_statement) &&
X (x->storage_as.string.dim != extra_tc_association)))
X err("not a statement or association",x);
X if (x->storage_as.string.dim == extra_tc_statement)
X return(sqlrtl_release_statement(x));
X else
X return(sqlrtl_release(x));}
X
XLISP sqlrtl_error_buffer(LISP assoc,LISP resetp)
X{struct association *a;
X long iflag,len;
X char *end;
X LISP s;
X a = get_association(assoc,1);
X if NNULLP(resetp)
X {memset(a->error_buffer,0,a->error_buffer_size);
X return(NIL);}
X iflag = no_interrupt(1);
X if (end = memchr(a->error_buffer,0,a->error_buffer_size))
X len = end - a->error_buffer;
X else
X len = a->error_buffer_size;
X s = strcons(len,a->error_buffer);


X no_interrupt(iflag);
X return(s);}
X
X

XLISP sqlrtl_association_statements(LISP assoc)
X{struct association *a;
X a = get_association(assoc,0);
X return(a->statements);}
X
Xvoid extra_gc_scan(LISP ptr)
X{struct association *a;
X struct statement *s;
X switch(ptr->storage_as.string.dim)
X {case extra_tc_association:
X a = (struct association *) ptr->storage_as.string.data;
X a->args = gc_relocate(a->args);
X a->statements = gc_relocate(a->statements);
X break;
X case extra_tc_statement:
X s = (struct statement *) ptr->storage_as.string.data;
X s->association = gc_relocate(s->association);
X s->param_alist = gc_relocate(s->param_alist);
X s->select_alist = gc_relocate(s->select_alist);
X s->cursor = gc_relocate(s->cursor);


X break;
X default:
X errswitch();}}
X

XLISP extra_gc_mark(LISP ptr)
X{struct association *a;
X struct statement *s;
X switch(ptr->storage_as.string.dim)
X {case extra_tc_association:
X a = (struct association *) ptr->storage_as.string.data;
X gc_mark(a->args);
X gc_mark(a->statements);
X break;
X case extra_tc_statement:
X s = (struct statement *) ptr->storage_as.string.data;
X gc_mark(s->association);
X gc_mark(s->param_alist);
X gc_mark(s->select_alist);
X gc_mark(s->cursor);


X break;
X default:
X errswitch();}

X return(NIL);}
X
Xvoid extra_gc_free(LISP ptr)
X /* release storage allocated. As an extra feature we could
X release associations and statements that were not
X otherwise released. */
X{free(ptr->storage_as.string.data);}
X
Xvoid extra_prin1(LISP ptr,FILE *f)
X{struct association *a;
X struct statement *s;


X char buff[512];
X switch(ptr->storage_as.string.dim)

X {case extra_tc_association:
X a = (struct association *) ptr->storage_as.string.data;
X sprintf(buff,"#{SQL ASSOCIATION %p}",a);
X fput_st(f,buff);
X break;
X case extra_tc_statement:
X s = (struct statement *) ptr->storage_as.string.data;
X sprintf(buff,"#{SQL STATEMENT %p}",s);


X fput_st(f,buff);
X break;
X default:
X errswitch();}}
X

Xvoid init_sql_rdb(void)
X{long j;
X set_gc_hooks(tc_extra,
X NULL,
X extra_gc_mark,
X extra_gc_scan,
X extra_gc_free,
X &j);
X set_print_hooks(tc_extra,extra_prin1);
X gc_protect(&associations);
X gc_protect_sym(&sym_ascii_string,"ascii_string");
X gc_protect_sym(&sym_generalized_number,"generalized_number");
X gc_protect_sym(&sym_generalized_date,"generalized_date");
X gc_protect_sym(&sym_varchar,"varchar");
X gc_protect_sym(&sym_varbyte,"varbyte");
X gc_protect_sym(&sym_list_varbyte,"list_varbyte");
X gc_protect_sym(&sym_table,"table");
X gc_protect_sym(&sym_list,"list");
X gc_protect_sym(&sym_update,"update");
X gc_protect_sym(&sym_read_only,"read-only");
X gc_protect_sym(&sym_insert_only,"insert-only");
X gc_protect_sym(&sym_begin,"begin");
X gc_protect_sym(&sym_end,"end");
X gc_protect_sym(&sym_abort,"abort");
X init_subr_1("rdb-describe-association",sqlrtl_describe_association);
X init_subr_1("rdb-describe-statement",sqlrtl_describe_statement);
X init_lsubr("rdb-sql-associate",sqlrtl_associate);
X init_subr_1("rdb-sql-release",sqlrtl_release_generic);
X init_subr_1("rdb-sql-release-statement",sqlrtl_release_statement);
X init_subr_1("rdb-sql-release-association",sqlrtl_release);
X init_subr_0("rdb-sql-associations",sqlrtl_associations);
X init_subr_1("rdb-sql-association-statements",sqlrtl_association_statements);
X init_subr_2("rdb-sql-execute-immediate",sqlrtl_execute_immediate);
X init_subr_2("rdb-sql-prepare",sqlrtl_prepare);
X init_subr_1("rdb-sql-statement-params",sqlrtl_statement_params);
X init_subr_1("rdb-sql-statement-selects",sqlrtl_statement_selects);
X init_subr_1("rdb-sql-statement-association",sqlrtl_statement_association);
X init_subr_3("rdb-sql-declare-cursor",sqlrtl_declare_cursor);
X init_subr_1("rdb-sql-open-cursor",sqlrtl_open_cursor);
X init_subr_1("rdb-sql-close-cursor",sqlrtl_close_cursor);
X init_subr_1("rdb-sql-fetch",sqlrtl_fetch);
X init_subr_2("rdb-sql-fetch-many",sqlrtl_fetch_many);
X init_subr_2("rdb-sql-execute",sqlrtl_execute);
X init_subr_2("rdb-sql-get-param",sqlrtl_get_param);
X init_subr_2("rdb-sql-get-column",sqlrtl_get_column);
X init_subr_3("rdb-sql-set-param",sqlrtl_set_param);
X init_subr_1("rdb-sql-num-batch-rows",sqlrtl_sqlca_num_batch_rows);
X init_subr_1("rdb-sql-count",sqlrtl_sqlca_count);
X init_subr_2("rdb-sql-error-buffer",sqlrtl_error_buffer);


X printf("Enhancements (C) Copyright 1994 Mitech Corporation.\n");}

END_OF_FILE
if test 26635 -ne `wc -c <'sql_rdb.c'`; then
echo shar: \"'sql_rdb.c'\" unpacked with wrong size!
fi
# end of 'sql_rdb.c'
fi
echo shar: End of archive 2 \(of 3\).
cp /dev/null ark2isdone


MISSING=""
for I in 1 2 3 ; do
if test ! -f ark${I}isdone ; then
MISSING="${MISSING} ${I}"
fi
done
if test "${MISSING}" = "" ; then
echo You have unpacked all 3 archives.
rm -f ark[1-9]isdone
else
echo You still need to unpack the following archives:
echo " " ${MISSING}
fi
## End of shell archive.
exit 0
